# 证明算法
## 复制证明PoRep
副本生成和零知识证明是复制证明的两个阶段：
### 副本生成
下面开始以32GB扇区的生成为例介绍Filecoin复制证明算法中复制的流程：

1. 根据需要存储的原始数据，按顺序填充出一个32GB大小的源文件，称为UnSealedFile，在此之上构造出一棵默克尔树，称为TreeD，其根称为CommD。
2. 生成一个replica_id，使用存储的源数据构造的默克尔树的树根(CommD)和存储服务提供者在网络中的身份ID，再加上这次存储生成的最终扇区的ID，以及生成该扇区时从链上取的随机数，再加上一个算法的版本号（用来区分每种算法，目前Filecoin中存在V1和V1_1算法，但是V1已经停用），通过哈希算法构造出一个数据。
3. 使用replica_id计算填充预先构造好形状的图形，计算得出一个深度鲁棒图，在该步骤中，需要生成每层32GB大小的空间，共11层。由于目前采用的哈希算法是SHA256，一个数据节点的大小是32B，因此每层共需计算1G(230)个节点。每个节点都会依赖本层的8个父节点和上层的6个父节点，根据这14个值（如果没有，比如第一层就没有上层，第一个就没有向前的父节点，则使用0填充这些节点）和replica_id进行哈希计算，得出当前节点的值。
4. 对11层每一列对应位置的节点进行哈希计算（目前哈希算法使用PoseidonHasher），得出一个32GB的文件，称为TreeC，其树根称为CommC。
5. 对步骤3中产生的最后一层和原始数据构造出的UnSealedFile进行简单的模加操作，生成一个32GB的文件，称为SealedFile，在此之上构造一棵默克尔树，称为R_LAST_TREE，将其根和CommC进行简单的计算，生成CommR。
6. 向链上报告CommR、存储的源文件的信息、存储服务提供者在网络中的ID、扇区ID、取随机数的高度（以此取得随机数的值，需要注意的是这里限制了做复制证明算法的时间，限制了入场的门槛）。
### 零知识证明
下面以32GB扇区的证明过程为例介绍Filecoin复制证明算法中的证明部分流程：

1. 存储服务提供者（即证明者）在上述副本生成过程中产生的CommR被大家认可之后（在网络中被打包执行，且执行结果正确），会等待一定的区块时间（目前是**150个区块高度**），然后取一个**此高度的随机数**，注意所有节点都可以知道这个信息（都是在确定高度发生的确定的事）。
2. 存储服务提供者根据这个随机数，生成若干个挑战节点的位置（其在最后的SealedFile的位置），根据这些位置，读取之前的所有layer、TreeC、R_LAST_TREE的对应位置的节点的数据，并且在提取layer的数据信息时，还会额外提取生成这些信息的信息（即之前所述的父节点）。至此，证明已经完成了。回顾一下这些信息生成的过程，可以发现中间每个环节都使用了哈希函数生成下一个节点，且中间有一个明文(replica_id)参与运算，存储服务提供者几乎不能构造出一个假的信息满足这些哈希关系。但是这段证明很长，在网络中存储这个信息需要付出很大代价，为此需要进行下一步，即零知识证明。
3. 根据这些信息，构造一个零知识证明电路，最后生成一段Proof。
4. 将Proof送到网络里的其他节点上，一旦该消息被网络打包进行验算，所有的验证者都可以根据明文(replica_id)信息验证这段Proof是否合法，从而验证存储服务提供者是否真的用复制证明算法存储数据。
## 时空证明PoSt
### WinningPoS
**由获得出块权的存储服务提供者对随机选定的扇区提供证明。**
**原理：**在每个周期的开始，通过Filecoin的Expected Consensus算法选择少数存储服务提供者来创建新区块。每个被选择创建区块的存储服务提供者必须在当前Epoch结束之前提交一份证明，以证明其保留了所提议区块中包含的数据的密封副本。如果存储服务提供者错过了纪元结束期限，那么就会错过出块和获得出块奖励的机会。在这种情况下不会产生任何罚款。
### WindowPoSt
**每一个存储服务提供者都需要周期性地每24小时对所有扇区提供证明。**
**原理：**在WindowPoSt中，每24小时称为一个“证明期”，并细分为一系列30分的不重合的区间，所以在任何给定的24小时证明期内总共有48个窗口期。每个存储服务提供者必须在24小时内证明所有活跃分区的可用性。单个证明计算的约束将单个证明限制为2349个扇区（一个分区），每个扇区有10个挑战点。
# Filecoin的组成
**原理：**Filecoin协议通过区块奖励来激励存储服务提供者参与每一轮的出块选举。每一轮可能有数个（当前设定为平均5个）存储服务提供者获得出块权，正确出块可获取区块奖励。每一个存储服务提供者赢得选举的概率与其存储量在全网总存储量中的占比成正比。这依赖于存储算力共识系统，该系统维持一个全网算力表，正确跟踪每一个存储服务提供者的算力变化。
## 区块
在网络中传播的实际区块结构：
```go
type BlockMsg struct {
    Header 			*BlockHeader
    BlsMessage 		[]cid.Cid  // *Message
    SecpkMessages 	[]cid.Cid  // *signedMMessage
}
```
区块内的消息在libp2p网络中传播时并没有传播整个消息，而是传播消息在Filecoin网络中的CID，这样做的原因是：

1. 消息在网络中传播时需要占用较多的网络资源。
2. 消息产生后会向全网广播，每个节点接收消息后会将其维护在消息池中或存储在节点数据库中，也就是说**根据CID能够搜索到具体的消息。**

消息结构：消息即交易，必须包括源地址、目的地址、nonce和Gas费用等信息
```go
type Message struct {
    Version    uint64           // 版本号，用于指定消息的版本

    To         address.Address  // 接收消息的目标地址

    From       address.Address  // 发送消息的源地址

    Nonce      uint64           // 发送地址的账户状态的一个数字，用于防止重复提交相同的消息

    Value      abi.TokenAmount  // 消息中传递的货币或代币的数量

    GasLimit   int64            // 消息所允许的最大燃料量（Gas Limit），用于限制消息执行所需的最大计算步数

    GasFeeCap  abi.TokenAmount  // 燃料费用上限，指定执行消息所愿意支付的每单位燃料的最高价格

    GasPremium abi.TokenAmount  // 燃料费用溢价，指定执行消息所愿意支付的每单位燃料的额外费用，以提高交易的优先级

    Method     abi.MethodNum    // 要调用的合约方法的数字表示形式，用于标识合约中要执行的具体方法

    Params     []byte           // 要传递给合约方法的参数的字节数组表示形式
}

```
### TipSet
根据Filecoin网络的预期共识，每个周期可能会选出多个领导人，即每一轮生产0个或多个区块。Filecoin将同一网络中同一高度并且基础区块和权重相同的区块在逻辑上划分到一个集合中，这个集合被定义为TipSet。
Filecoin是由TipSet组成的链。构成TipSet的元素包括链高度(ChainEpoch)和区块集合。TipSet的结构定义如下所示：
```go
type TipSet struct {
	cids []cid.Cid
    blks  []*BlockHeader
    height abi.ChainEpoch
}
```
## 消息池
消息池(message pool)也称为mpool或mempool，充当Filecoin点对点网络中传播链下消息的接口。节点利用消息池来维护一组它们想要传输到Filecoin虚拟机并添加到链上的消息。
消息池具体表现为网络中每个节点保存的消息列表。当一个节点将一条新消息添加到消息池时，该消息将被libp2p的**PubSub**协议传播到网络的其他节点。节点需要**订阅相应的PubSub主题**才能接收到传播的消息。
使用GossipSub的消息传播不会立即到达所有节点，因此，在不同节点上的消息同步会有一些延迟，也就是说，不同节点上的消息池不会保持为一致的同步状态。
### 消息传播

1. 消息产生推送到节点的消息池，并将消息发布到/fil/msgs/频道。
2. 将消息传播到对等节点列表中的其他节点，依次继续传播并最终到达所有存储服务提供者的消息池中。
3. 区块生产者从消息池中挑选消息，并将其打包在一个区块中。
4. 区块生产者在/fil/blocks/频道中发布新生产的区块，该区块传播到网络中的所有节点。
5. 收到区块的节点将校验其打包消息的合法性，如果消息无效，则不再进行转发。GossipSub协议的更新增强版本包括许多攻击缓解策略，特别是节点评分机制。当节点收到一个无效的消息时，会降低发送者的评分，当某个节点的评分降低到一定程度后，将不再处理该节点的任何消息，类似黑名单。节点分数不与其他节点共享，由每个节点在本地保存与其交互的节点的分数。
### 消息同步
消息最终都是要被执行的，这样各个节点才能最终维护相同的状态。消息执行通过虚拟机系统完成。
## 链同步
### 链同步过程

1. 当节点第一次加入网络时，它首先发现对等节点，并订阅/fil/blocks和/fil/msgs GossipSub频道。
2. 新加入的节点监听由其他节点传播的新区块，然后选择一个区块作为BestTargetHead（最佳目标区块链链头，具有一个高度），并开始从TrustedCheckpoint同步区块链到这个高度，TrustedCheckpoint默认为GenesisBlock或GenesisCheckpoint。
3. 为了挑选BestTargetHead，需要比较高度和重量的组合——这些值越高，所选择的区块是主链的机会就越高。如果有两个区块高度相同，则节点应选择重量较大的区块。
4. 一旦节点选择了BestTargetHead，就会使用**BlockSync**协议来获取区块并达到当前的高度。达到当前高度之后，节点处于CHAIN_FOLLOW模式。在这种模式下，节点使用GossipSub接收新的区块。如果节点获悉一个区块，却没有通过GossipSub接收到，则使用Bitswap协议来获取该区块。

### 链同步适用过程

1. 节点第一次加入网络或导入已有网络的快照(snapshot)，首先需要达到当前的最新状态，之后才能验证或扩展区块链。
2. 节点没有和区块链保持同步，例如，出现网络连接短暂断开的情况。
3. 在节点正常运行期间，一旦本地状态与链上最新状态存在差异，将会触发链同步。
### 链同步过程涉及的区块同步协议

1. GossipSub是libp2p的PubSub协议，用于传播消息和区块。它主要用于上面的第三种场景——当节点需要与最新生成的区块保持同步时。
2. BlockSync用于同步区块链的特定部分，即获取从一个特定的高度和到一个特定的高度的区块和消息。
3. Hello协议，主要用于两个对等节点第一次“见面”（即第一次彼此连接）时。根据Hello协议规则，对等节点在第一次“见面”时会交换区块链链头。
4. 此外，在一个节点已经同步好（处于“紧跟”模式时），但GossipSub传播区块失败的情况下，系统使用Bitswap协议来请求和接收区块。

总之，作为用来获取区块链的一部分的协议，GraphSync是比Bitswap更有效的版本。Filecoin节点也是libp2p节点，因此可以运行其他多种协议。与Filecoin中的任何部分一样，节点可以选择使用其他协议来实现。但是，节点必须实现本规范中描述的ChainSync版本，才能被视为Filecoin的实现。
### 链同步过程

1. 验证内部状态（INIT状态）。必须验证数据结构和本地区块链，资源昂贵的验证可能会被跳过，但节点自己承担风险。
2. 引导网络，启动同步（BOOTSTRAP状态）。获得一组“足够安全”的对等节点，启动GossipSub频道。
3. 同步检查点（SYNC_CHECKPOINT状态）。从TrustedCheckpoint（默认为GenesisCheckpoint）开始获取TrustedCheckpoint所指向的区块以及该区块的父区块，获取StateTree。
4. 追赶链头（CHAIN_CATCHUP状态）。维护一组TargetHeads(BlockCid)，并从中选择BestTargetHead，同步到最近观察到的链头，验证链头后面的区块（请求中间区块）。随着验证的进行，TargetHeads和BestTargetHead可能会发生变化，因为最新生成的区块将会到来，而之前TargetHeads和BestTargetHead指向的一些链头或路径可能已无法验证。当节点“赶上”BestTargetHead（检索所有状态，链接到本地区块链，验证所有区块，等等）时，链同步完成。
## 存储算力共识
存储算力共识(Storage Power Consensus，SPC)系统是Filecoin**节点就系统状态达成一致**的主要接口。
# Filecoin存储服务保障
## 扇区
### 生命周期
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1498431/1690779993444-a235cc38-f178-4836-a535-51f94ab5d968.png#averageHue=%23fdfdfd&clientId=u7f9902ed-a2ca-4&from=paste&height=631&id=u384f8a45&originHeight=1262&originWidth=2816&originalType=binary&ratio=2&rotation=0&showTitle=false&size=357963&status=done&style=none&taskId=u0333189b-bc89-4a2f-8934-ddeafdf8e19&title=&width=1408)
一个扇区在其生命周期内可以处于下列状态之一：

1. **Packing**，为新创建的扇区添加数据片，该数据片可以是验证数据，也可以是非验证数据。
2. **Sealing**，扇区的封装过程，主要状态有**Precommitted**和**Committed**：
   1. Precommitted，存储服务提供者封装扇区并提交，对应的方法为`miner.PreCommitSector`
   2. Committed，生成一个封装证明并提交，对应的方法为`miner.ProveCommitSector`。
3. **Proving**，存储服务提供者生成有效的**WindowPoSt**证明并及时提交，对应的方法为miner.SubmitWindowedPoSt。此状态需要扇区每个周期的WindowPoSt正确执行，一旦发生错误将会进入Faulty状态，即存储服务提供者无法生成正确证明（参见12.1.4节）。如果想恢复故障扇区，需要存储服务提供者通过miner.DeclareFaultRecovered方法宣布恢复，此时扇区进入Recovering状态（参见12.1.5节）。
4. **Terminated**，存储服务提供者通过调用miner.TerminateSectors方法提前终止扇区，或在连续14个证明周期失败时标记为此状态。
5. **Expired**，扇区已过期，如果存储需求者不续约，那么存储服务提供者可以删除扇区，且不会造成任何损失。
### 扇区封装
在存储服务提供者的设备上，扇区在密封前后存在两种状态—未封装扇区和封装扇区。

1. 未封装扇区。原始数据的扇区，将未封装扇区默克尔树的根哈希值（UnsealedCID，也称为“数据承诺”）赋给扇区结构体的CommD字段。
2. 封装扇区。已编码的扇区，为验证过程做准备，将封装扇区默克尔树的根哈希值（SealedCID，也称为“副本承诺”）赋给扇区结构体的CommR字段。

扇区的定义：
```go
type SectorInfo struct {
    // PreCommit2
    CommD *cid.Cid
    CommR *cid.Cid
    Proof []byte
}
```

封装扇区的过程通过复制证明(Proof-of-Replication，PoRep)完成。封装扇区是一个计算密集型的过程，会形成扇区的唯一编码。一旦数据被封装，存储服务提供者会生成证据，并对证明运行zk-SNARK压缩。最后，将压缩结果提交给区块链作为存储承诺的证明。
## 区块生产
### 出块流程
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1498431/1690781521894-4163497b-a092-4e30-9c47-d26168b301e7.png#averageHue=%23f9f9f9&clientId=u7f9902ed-a2ca-4&from=paste&height=541&id=u143f0f45&originHeight=1858&originWidth=2070&originalType=binary&ratio=2&rotation=0&showTitle=false&size=392835&status=done&style=none&taskId=u4ce3fce7-0844-4a50-bada-b74a70a4475&title=&width=603)

1. 必要数据准备，如baseinfo、Ticket等。
2. 尝试去生产一个块mineOnce。
3. 获得出块权，将要生产一个块。
4. 获取时空证明需要的随机数。
5. 进行时空证明计算。
6. 从消息池选择消息，创建一个新的区块。
7. 新的区块发送到同步节点进行“合法性”验证，通过后对全网广播。
### 出块周期
目前Filecoin主网的出块周期是**30秒**，也就是链高度每30秒增长一次。对于区块生产者来说，必须在周期开始后的30秒内完成选择消息、创建区块、广播区块的过程。在目前的Lotus逻辑中，每个周期开始后有6秒时间等待上一轮的所有出块，故实际上区块在新周期开始后的6秒内能在Filecoin网络中完成验证即可，否则将成为孤块。
## 节点质押
Filecoin中的质押机制是指存**储服务提供者算力增长过程、区块奖励释放过程及市场数据交易过程**中涉及的代币质押与释放机制。
代币质押机制的设计，既需要考虑新存储服务提供者加入网络的成本，也需要考虑应对早期扇区故障、罚款的费用，同时还要激励存储服务提供者长期维护网络健康，稳定地发展。
Filecoin有三种不同的质押机制：前置质押、后置质押、市场质押。

1. 前置质押：指存储服务提供者封装扇区的过程中需要质押一定的FIL代币确保数据的正常封装（算力正常增长），其中包含两个部分，第一部分指在数据封装完成后（PreCommitSector消息）需要质押一定量的FIL，以督促存储服务提供者完成密封数据（扇区）的证明过程，第二部分指在完成扇区证明（ProveCommitSector消息）时需要质押一定量的代币。在这个过程中，第一部分质押会在扇区证明完成之前释放，如果ProveCommitSector未及时上链，则会被销毁，第二部分质押需要在扇区到期（当前默认540天）之后一次性释放。
2. 后置质押：指存储服务提供者通过生产区块得到的奖励，先释放25%，剩余75%将会在180天内线性释放。
3. 市场质押：指客户端数据交易需要质押一定量的代币，以保证市场交易能够正常进行。
## 证明子系统
### 扇区时空证明管理器
Filecoin的时空证明(PoSt)会被WinningPoSt和WindowPoSt调用。

1. WinningPoSt是存储服务提供者在出块时对已经提交的扇区进行证明，证明扇区保存的数据依然存在。
2. WindowPoSt是在对应的周期内对已经提交的扇区进行证明，证明数据一直被持续地保存。
### 扇区复制证明管理器
复制证明(Proof-of-Replication，PoRep)用于证明数据的一个单独的副本已经在一个特定的扇区内创建成功。可以保证每份数据的存储都是独立的。
复制证明在Filecoin系统中只会在第一次存储数据时，即封装扇区的过程中发生。扇区复制证明管理器就是用来管理扇区封装的，主要分为两个步骤：

1. 填充扇区并生成CommD。当存储服务提供者节点接收到客户端据时，会将其放入一个扇区，一旦扇区填满，就会生成CommD（数据承诺，又名UnsealedSectorCID），表示该扇区中包含的所有片段CID的根节点。
2. 封装和生成CommR。在封装过程中，扇区数据（由CommD标识）通过一系列图和哈希过程进行编码，以创建唯一的副本。结果副本的Merkle树的根哈希值是CommRLast。CommRLast与CommC（复制证明的另一个Merkle根输出）一起进行哈希计算产生CommR（复制承诺，又名SealedSectorCID），记录到公共区块链中。CommRLast由存储服务提供者私下保存，以备将来在证明时空时使用，但不会保存到链中。
