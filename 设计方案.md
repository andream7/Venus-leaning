[toc]



### 工作规划

1. 部署k8s
2. 功能规划✔️
3. 技术方案
4. 原型图设计
5. V0.1版本功能规划（最核心）

## 功能设计

## 配置中心

1. 角色配置
2. 用户组配置
3. 环境配置（线上、线下）
4. 登陆日志
5. 系统设置

### 工作台

1. 待办事项
2. 系统公告

### 流水线

1. 流水线分组
   1. 开发流水线
   2. 部署流水线
   3. 生产流水线

1. 列表（搜索，过滤，查找）

   1. 流水线名称
   2. 最近运行状态（第1次运行 成功）
   3. 最近运行阶段（测试，构建）
   4. 触发信息（手动触发、git提交自动触发）
   5. 最近运行开始时间
   6. 收藏button
   7. 运行button
   8. 编辑button

2. 新建流水线

   1. 流水线模板
      1. 测试，构建
      2. 测试，构建镜像
      3. 测试，构建镜像，发布到kubernetes集群
      4. 自定义流水线流水线配置（点击模板之后进入）

3. 流水线创建配置

   > 1. 动态添加测试构建，代码扫描，构建，部署等模块
   > 2. 不同模块的执行顺序可以配置
   > 3. 每个模块中都可以并行配置没有前后一来的执行计划
   > 4. 可以配置模块是手动触发还是自动触发（支持人工卡点）

   1. 添加流水线源
      1. 代码源（默认github）
      2. jenkins
   2. 测试
   3. 构建
   4. 部署
   5. 代码扫描
   6. 构建
   7. 测试构建
   8. 镜像构建
   9. 部署
   10. 工具
   11. 代码

4. 保存并运行（运行备注）

5. 流水线详情（最近运行、运行历史）

   1. 运行历史：（运行记录列表，可进行排序，触发时间筛选）
      1. No（编号）
      2. 运行记录
      3. 状态（失败/成功）
      4. 运行详情
      5. 触发信息
      6. 持续时间
      7. 开始时间
      8. 操作人
      9. 运行备注
      10. 查看详情button
   2. 最近运行：
      1. 主要显示配置的流水线、触发信息等，右侧有编辑、运行按钮
      2. 可以将配置的流水线保存为流水线模板
      3. 左侧显示运行信息（触发信息、开始时间、持续时间、产物）

### 测试用例

1. 测试用例库（分不同服务，~~比如venus-auth的所有测试用例在该用例库~~，或者一个服务在一个测试用例组）
2. 测试计划：
   1. 思路：
      1. 从测试用例库获取本次要执行的测试用例
      2. 可以是单个测试用例
      3. 也可以是多个测试用例，按照顺序组成一个测试计划
   2. 测试计划列表（排序，筛选，从用例库选择用例）
      1. 用例名
      2. 用例等级
      3. 状态
      4. 用例类型
      5. 标签
      6. 前置条件
      7. 执行用例button
   3. 从用例库选择用例
      1. 展示全部用例
         1. 选择列表可以关键词搜索
         2. 可以多选
      2. 创建用例（需要在用例库创建，在这里选择）
3. 用例库
   1. 查看用例库用例（从数据库拉取）
   2. 创建用例
   3. ***执行用例逻辑***
      1. 根据用例编号（id），执行对应的shell脚本
4. 用例执行过程
   1. 根据id获取shell脚本
   2. 脚本关联到已经实现好的docker- compose.yaml文件
   3. 创建一个pod，在pod中，根据镜像运行相关容器
   4. 进阶：判断用例公用的镜像，复用对应pod
5. 测试的触发方式
   1. 手动触发：在测试用例模块手动触发
   2. 自动触发：运行流水线时添加自动测试



### 代码发布管理

代码提交之后，自动触发新建流水线、选择流水线模板、运行流水线

1. 仓库列表
   1. 应用名称
   2. 标识符
   3. 最新版本
   4. 负责人
   5. git地址
   6. 编译镜像
   7. 仓库配置
   8. 发布版本
2. 新建仓库（基本配置，构建配置，发布配置）
3. 版本列表（搜索（版本号，发布者，commit id，分支，git tag）
   1. 版本类型（线下/线上）
   2. 版本编号
   3. commit message
   4. 分支名称
   5. Commit ID
   6. 发布人
   7. 发布时间
   8. 编译状态（成功/失败）
   9. 查看构建过程（jenkins）
4. 发布版本（新建构建）
   1. 发布版本（线上/线下）
   2. 版本号（自增生成）
   3. 选择分支/标签/版本
   4. 展示发布过程
   5. （可选）发布模式：线上、线下

## 详细设计

### 流水线

触发方式：

1. 图形编辑面板（jenkinsfile out of scm）
2. 代码仓库（jenkins in scm）

流水线基于jenkenfile、Kubernetes Jenkins Agent。

1. jenkins Agent可以动态扩缩容
2. jenkins Controller和Agent已Pod形式运行在k8s节点上
3. Controller运行在其中一个节点上，配置数据存储在一个持久卷声明中。Agent 运行在各个节点上，但可能不会一直处于运行状态，而是根据需求动态创建并自动删除。
4. 当 Jenkins Controller 收到构建请求，会根据标签动态创建运行在 Pod 中的 Jenkins Agent 并注册到 Controller 上。当 Agent 运行完任务后，将会被释放，相关的 Pod 也会被删除。

### 测试用例

1. 测试用例作为pod运行在其中
2. testcase记录测试用例状态
3. summary记录汇总状态
4. testcase和summary是两个crd

组件

1. sidecar容器：测试用例所在pod
2. operator：同步状态
   1. watch主资源（testcase对象），为每个testcase对象创建一个pod，pod中运行测试用例
   2. wathc次资源（pod对象），当测试用例运行完成，获取exitcode
      1. 向testcase对象中更新状态，并更新summary实例状态
      2. 向sidecar发送pod延迟退出周期

https://juejin.cn/post/7117220924843098143



部署流程：配置github action进行自动打包、进行自动化镜像打包、运行自动化测试、部署到k8s

测试流程：通过api接口，触发测试用例镜像pull，测试环境配置，测试脚本准备，将上述文件放到pod运行，使用oper

1. 我想开发基于k8s的自动化测试框架，每个测试用例作为一个pod运行，这些pod由TestCase对象创建，最终在testcase实例中记录pod的状态。测试用例运行时的pod是sider容器，同步状态使用operator，请问详细方案如何设计？

2. 我应该了解k8s、Docker和operator的哪些技术？

3. 如何使用使用k8s API来创建、更新和删除pod？

4. 什么是Kubernetes Sidecar容器？

5. kubernetes有哪几种部署方式？

6. venus我有测试用例，如何将这个测试用例打包为在pod中运行的镜像（dockerfile配置环境，python执行测试命令

   配置github action进行自动打包

## 部署设计

## Docker原理

### namesapce

1. 在 Linux 系统中创建线程的系统调用是 clone()，创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：

```
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 
```

这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。

2. namespace还有Mount、UTS、IPC、Network和User。
   1. IPC：隔离System V IPC和POSIX消息队列
   2. Mount：隔离文件系统挂载点，每个容器能看到不同的文件系统层次结构。
   3. UTS：隔离主机名和域名

### 容器镜像

1. 容器镜像实际上是：rootfs（根文件系统）

2. 容器rootfs由三个部分组成：可读写层、Init层、只读层（我们可以通过docker commit和push指令，保存被修改过的可读写层，并上传到Docker Hub上，供其它人增强使用；且原先的只读层里的内容不会有任何改变）

3. docker镜像的设计中，引入了层（layer）的概念，也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。docker使用的rootfs往往由多个“层”组成：

   ```
   # 该镜像由5个layer组成，这5层就是5个增量rootfs
   # 在使用镜像时，Docker 会把这些增量联合挂载在一个统一的挂载点上
   docker image inspect ubuntu:latest
   ...
        "RootFS": {
         "Type": "layers",
         "Layers": [
           "sha256:f49017d4d5ce9c0f544c...",
           "sha256:8f2b771487e9d6354080...",
           "sha256:ccd4d61916aaa2159429...",
           "sha256:c01d74f99de40e097c73...",
           "sha256:268a067217b5fe78e000..."
         ]
       }
   ```

   

## Docker cli

```
docker run -it /bin/sh
-i: stdin, 为了能够在 tty 中输入信息，还需要同时开启 stdin（标准输入流）
-t: tty, Linux 给用户提供的一个常驻小程序，用于接收用户的标准输入，返回操作系统的标准输出
# 相当于在yaml中配置
  - name: shell
    image: busybox
    stdin: true
    tty: tru
```

```
# 共享宿net、IPC、PID
spec:
  hostNetwork: true
  hostIPC: true
  hostPID: true
```



## dockerfile

```dockerfile
FROM 909336740/nginx:v1.12.2
# 使用的用户
USER root
# env设置环境变了
ENV WWW /usr/share/nginx/html
ENV CONF /etc/nginx/conf.d
# run执行命令，修改时区
RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &&\ 
    echo 'Asia/Shanghai' >/etc/timezone
# workdir指定工作目录
WORKDIR $WWW
# add添加内容
ADD index.html $WWW/index.html
ADD demo.od.com.conf $CONF/demo.od.com.conf
# expore 暴露端口
EXPOSE 80
# 为启动的容器指定默认要运行的程序，程序结束时容器也会结束
CMD ["nginx","-g","daemon off;"]
```

demo.od.com.conf：

```
vi demo.od.com.conf
server {
   listen 80;
   server_name demo.od.com;

   root /usr/share/nginx/html;
}

# 下载并写入index.html
wget www.baidu.com -O index.html
docker build . -t 909336740/nginx:baidu
docker run --rm -p80:80 909336740/nginx:baidu
```

### dockerfile四种网络类型

- Bridge contauner（NAT） 桥接式网络模式(默认)
- None(Close) container 封闭式网络模式，不为容器配置网络
- Host(open) container 开放式网络模式，和宿主机共享网络
- Container(join) container 联合挂载式网络模式，和其他容器共享网络

## K8s

### pod

1. pod是k8s能被运行的最小单位

2. 一个pod里面可以有多个容器，所有容器共享一个network namespace，并且可以声明共享一个Volume

3. 一个pod里面运行多个容器，被称为SideCar模式

4. 调度、网络、存储、安全相关属性，基本上是Pod级别

   1. HostAliases：定义Pod的hosts文件内容

      1. ```
         spec:
           hostAliases:
           - ip: "10.1.2.3"
             hostnames:
             - "foo.remote"
             - "bar.remote"
         ```

   2. shareProcessNamespace=true：Pod容器里共享PID Namespace

      1. ```
         spec:
           shareProcessNamespace: true
         ```

      2. ```
         # 共享宿net、IPC、PID
         spec:
           hostNetwork: true
           hostIPC: true
           hostPID: true
         ```

   3. Container 

      1. **ImagePullPolicy**：定义了镜像拉取的策略

         - 默认是 Always，即每次创建 Pod 都重新拉取一次镜像。
         - 可以定义为 Never 或者 IfNotPresent，则意味着 Pod 永远不会主动拉取这个镜像，或者只在宿主机上不存在这个镜像时才拉取。

      2. Lifecycle Hooks：容器状态变化时触发的一系列hooks

         ```
         spec:
           containers:
           - name: lifecycle-demo-container
             image: nginx
             lifecycle:
               postStart:
                 exec:
                   command: ["/bin/sh", "-c", "echo Hello from the postStart handler > /usr/share/message"]
               preStop:
                 exec:
                   command: ["/usr/sbin/nginx","-s","quit"]
         ```

         

5. Pod状态

   1. **Pending**：这个状态意味着，Pod 的 YAML 文件已经提交给了 Kubernetes，API 对象已经被创建并保存在 Etcd 当中。但是，这个 Pod 里有些容器因为某种原因而不能被顺利创建。比如，调度不成功。
   2. **Running**：这个状态下，Pod 已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创建成功，并且至少有一个正在运行中。
   3. **Succeeded**：这个状态意味着，Pod 里的所有容器都正常运行完毕，并且已经退出了。这种情况在运行一次性任务时最为常见。
   4. **Failed**：这个状态下，Pod 里至少有一个容器以不正常的状态（非 0 的返回码）退出。这个状态的出现，意味着你得想办法 Debug 这个容器的应用，比如查看 Pod 的 Events 和日志。
   5. **Unknown**：这是一个异常状态，意味着 Pod 的状态不能持续地被 kubelet 汇报给 kube-apiserver，这很有可能是主从节点（Master 和 Kubelet）间的通信出现了问题。

6. 水平扩展和滚动升级

   1. ReplicaSet：一个ReplicaSet对象，由副本数量和一个Pod模版组成，水平扩展/收缩就是修改副本数量。

      ```
      spec:
        # Pod副本数量是3
        replicas: 3
        selector:
          matchLabels:
            app: nginx
        template:
          metadata:
            labels:
              app: nginx
          spec:
            containers:
            - name: nginx
              image: nginx:1.7.9
      ```

7. RBAC：基于角色的权限控制

   ```
   kind: Role
   apiVersion: rbac.authorization.k8s.io/v1
   metadata:
     namespace: mynamespace
     name: example-role
   # rules定义权限规则
   rules:
   - apiGroups: [""]
     resources: ["pods"]
     verbs: ["get", "watch", "list"]
         ...
     # 相当于token
     secrets:
     - name: example-sa-token-vmfg6
   ```

8. Operator 工作原理

   利用k8s的自定义API资源（crd），来描述我们想要部署的“有状态应用”；然后在自定义控制器里，依据API对象的变化，完成部署运维等。

   ```
   # create etcd operator
   kubectl create -f example/deployment.yaml
   
   # pod进入running，自动创建一个crd
   kubectl get pods
   NAME                              READY     STATUS      RESTARTS   AGE
   etcd-operator-649dbdb5cb-bzfzp    1/1       Running     0          20s
    
   kubectl get crd
   NAME                                    CREATED AT
   etcdclusters.etcd.database.coreos.com   2018-09-18T11:42:55Z
   
   # 查看crd
   # 这个crd相当于告诉了k8s，如果有API group是etcd.database.coreos.com、API Kind是EtcdCluster的yaml被提交，k8s应该能识别。
   kubectl describe crd  etcdclusters.etcd.database.coreos.com
   Group:   etcd.database.coreos.com
     Names:
       Kind:       EtcdCluster
       List Kind:  EtcdClusterList
       Plural:     etcdclusters
       Short Names:
         etcd
       Singular:  etcdcluster
     Scope:       Namespaced
     Version:     v1beta2
   ```

   上述操作相当于在k8s里添加了一个叫EtcdCluster的自定义资源类型，Etcd Operator就是这个自定义资源的控制器。

   ```
   # 创建Etcd集群，只需编写EtcdCluster的yaml文件
   # example-etcd-cluster.yaml里描述是3节点Etcd
   $kubectl apply -f example/example-etcd-cluster.yaml
   
   $kubectl get pods
   NAME                            READY     STATUS    RESTARTS   AGE
   example-etcd-cluster-dp8nqtjznc   1/1       Running     0          1m
   example-etcd-cluster-mbzlg6sd56   1/1       Running     0          2m
   example-etcd-cluster-v6v6s6stxd   1/1       Running     0          2m
   ```

   

   

### Pod控制器

1. Pod控制器是Pod启动的一种模板，用来保证k8s里启动的pod按照预期运行
2. pod有多种控制器
   1. Deployment（常规发布）：Rolling update、Pause/resume、Canary deploy（金丝雀发布）、Rollback
   2. DaemonSet（Daemon作业）
   3. ReplicaSet（容器副本）
   4. StatefulSet（有状态任务）：Topology State、Storage State
   5. Job（一次性任务）
   6. Cronjob（定时任务）

### Name

1. k8s内部，使用“资源”来定义每一种逻辑概念，每种资源都应该有自己的名称。
2. “资源”有apiVersion、kind、metadata、spec、status等配置信息
3. “名称”通常定义在metadata中

### namespace

1. namespace用于隔离资源，使得对交付到k8s机群中的服务进行分类管理
2. k8s默认的namespace有default、kube-system、kube-public
3. 查询k8s中特定资源时，需要带上namespace

### Label

1. 一个labal可以对应多个资源，一个资源也可以有多个Label
2. 一个资源有多个Label，可以实现多维度管理
3. 标签组成：key=value
4. 与标签类似的是注解（annotation）

### Label选择器

1. 标签选择器目前有两个：基于等值关系（等于、不等于）和基于集合关系（属于、不属于、存在）
2. 许多资源支持内嵌标签选择器字段
   - matchLabels
   - matchExpressions

### Service

1. Service可以看作是一组提供相同服务的Pod对外访问接口
2. Service作用于哪些pod，通过Label选择器来定义

### ConfigMap

1. 应用配置管理

### Ingress

（七层服务发现）

1. Ingress是k8s集群在应用层对外暴露的接口

2. Service只能进行L4流量调度（ip+port）

3. Ingress可以调度不同的业务域

   ![1582188308711](https://github.com/ben1234560/k8s_PaaS/raw/master/assets/1582188308711.png)

### kubectl

k8s的命令行接口

### API Server

1. pod，service、RC的增删改查
2. 数据交换的枢纽

### Etcd

1. 包含在api server中，用于存储资源

### Controller Manager

1. 维护集群状态，如故障检测、自动扩展、滚动更新

### Scheduler

1. 资源调度、按照预定的调度策略将Pod调度到对应的机器

### kube-proxy

1. 负责为Service提供cluster内部的服务发现和负载均衡

### Kubelet

1. kubelet调用下层容器时，并不会直接调用Docker API，而是通过CRI（容器运行时接口）的gRPC接口来间接执行的。如果容器使用的是Docker，那么就会有一个叫dockershim的组件负责响应，这个组件会把CRI请求中的内容取出来，组装车Docker API发送给Docker Daemon。其他容器会有自己的插件。
2. CRI提供两组接口：
   1. 第一组，是 RuntimeService。它提供的接口，主要是跟容器相关的操作。比如，创建和启动容器、删除容器、执行 exec 命令等等。
   2. 第二组，则是 ImageService。它提供的接口，主要是容器镜像相关的操作，比如拉取镜像、删除镜像等等。



### k8s调度机制

#### 资源模型

```
spec:
  containers:
  - name: wp
  image: wordpress
  resources:
    requests:
      memory: "64Mi"
      cpu: "250m"
    limits:
      memory: "128Mi"
      cpu: "500m"
```

1. cpu是可压缩资源，资源不足时，pod只会“饥饿”，不会退出
2. 内存时不可压缩资源，资源不足时，Pod会因为OOM被内核kill
3. Pod 可以由多个 Container 组成，所以 CPU 和内存资源的限额，是要配置在每个 Container 的定义上的，而Pod整体资源配置，就由这些 Container 的配置值累加得到
4. requests：kube-scheduler只会按照requests计算
5. limits：设置Cgroup资源时，kubelet按照limit的值进行设置

#### QoS模型

- **Guaranteed**：Pod 里的每一个 Container 都同时设置了 requests 和 limits，并且 requests 和 limits 值相等的时候，这个 Pod 就属于 Guaranteed 
  - 建议将DaemonSet（亦或者类似的）的 Pod 都设置为 Guaranteed 的 QoS 类型，否则一旦被资源紧张被回收，又立即会在宿主机上重建出来，这样资源回收的动作就没有意义了
- **Burstable**：当 Pod 不满足 Guaranteed 的条件，但至少有一个 Container 设置了 requests。那么这个 Pod 就会被划分到 Burstable
- **BestEffort**：如果 Pod 既没有设置 requests，也没有设置 limits，那么它的 QoS 类别就是 BestEffort

#### cpuset

1. 在使用容器时，可以通过设置 cpuset 把容器绑定到某个 CPU 的核上，而不是像 cpushare 那样共享 CPU 的计算能力，这样CPU之间进行上下文切换的次数大大减少，容器里应用的性能会得到大幅提升。具体绑定到哪个cpu，由kubelet分配。

2. 实现方法：Pod 必须是 Guaranteed 的 QoS 类型

   

#### 调度策略

1. **Predicates**：开始调度一个pod时，k8s集群会同时启动16个goroutine，并发地计算所有Node的Predicates，最后返回可以运行这个pod的宿主机列表。
2. **Priorities**： 对得到的Node打分，范围0-10，得分最高的节点就是被Pod绑定的最佳节点。（一般是选择空闲cpu和内存最多的宿主机、资源分配最平衡的节点）
3. 

#### 抢占式调度



### kubeadm init



```
set -o errexit
set -o nounset
set -o pipefail

##这里定义版本，按照上面得到的列表自己改一下版本号

KUBE_VERSION=v1.26.1
KUBE_PAUSE_VERSION=3.9
ETCD_VERSION=3.5.6-0
# DNS_VERSION=1.8.4 # coredns需要特殊处理

##这是原始仓库名，最后需要改名成这个
GCR_URL=registry.k8s.io

##这里就是写你要使用的仓库
DOCKERHUB_URL=gotok8s

##这里是镜像列表，新版本要把coredns需要特殊处理
images=(
kube-proxy:${KUBE_VERSION}
kube-scheduler:${KUBE_VERSION}
kube-controller-manager:${KUBE_VERSION}
kube-apiserver:${KUBE_VERSION}
pause:${KUBE_PAUSE_VERSION}
etcd:${ETCD_VERSION}
# coredns:${DNS_VERSION} # coredns需要特殊处理
)

##这里是拉取和改名的循环语句
for imageName in ${images[@]} ; do
  docker pull $DOCKERHUB_URL/$imageName
  docker tag $DOCKERHUB_URL/$imageName $GCR_URL/$imageName
  docker rmi $DOCKERHUB_URL/$imageName
done
```

```
docker images
docker pull coredns/coredns:1.9.3
docker tag coredns/coredns:1.9.3 registry.k8s.io/coredns/coredns:1.9.3
```







## 排查

查看docker状态：

```
systemctl status kubelet
systemctl status etcd


journalctl -xeu kubelet
```

查看进程状态：

```
docker ps -a | grep kube | grep -v pause
docker logs <container id>
```

启动：

```
systemctl start docker

# 启动守护进程
systemctl daemon-reload
```

重启：

```
docker restart <container id>
```

关闭：

```
docker service docker stop
```



## 问题

1. ![image-20230221163027740](/Users/shukzhang/Library/Application Support/typora-user-images/image-20230221163027740.png)

   解决：https://blog.csdn.net/D1179869625/article/details/126929738

2. 如何排查，最后将问题定位在etcd（查看etcd日志 https://blog.csdn.net/qq_35566365/article/details/116455177）
